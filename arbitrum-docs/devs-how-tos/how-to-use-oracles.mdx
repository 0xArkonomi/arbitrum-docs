---
title: 'How to use oracles in Arbitrum'
sidebar_label: Use oracles
description: Learn how to integrate oracles into your dapp
reader-audience: developers who want to build on Ethereum/Arbitrum
content-type: how-to
---

import PublicPreviewBannerPartial from '../partials/_public-preview-banner-partial.md';

<PublicPreviewBannerPartial />

Oracles are web services that provide a connection between smart contracts and the outside world. They let decentralized apps (dApps) interact with off-chain data and services.

Familiarity with [oracles](../for-devs/concepts/oracles.mdx), smart contracts, and blockchain development is expected. If you’re new to blockchain development, consider reviewing our [Quickstart: Build a dApp with Arbitrum (Solidity, Hardhat)](../for-devs/quickstart-solidity-hardhat) before proceeding.

## Chainlink

[Chainlink](https://chain.link/) is a widely-recognized Web3 services platform that specializes in decentralized oracle networks. It lets you build Ethereum and Arbitrum dApps that connect to a variety of off-chain data feeds and APIs, including those that provide asset prices, weather data, random number generation, and more.

### Querying the price of $ARB through Chainlink

Here’s an example on how to use a price feed from Chainlink to query the current price of $ARB on-chain. We’ll use an interface provided by Chainlink that can be configured with the address of the proxy that holds the information we want to request, and wrap the operation in a contract.

Chainlink provides an npm package with the contracts needed to access their feeds. We first install that package in our project:

```tsx
yarn add @chainlink/contracts
```

To use a data feed, we retrieve the information through the `AggregatorV3Interface` and the proxy address of the feed we want to query.

```solidity
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
```

In this case, we want to obtain the current price of $ARB in $USD in Arbitrum One, so we need to know the address of the proxy that will provide that information. Chainlink maintains a list of price feed address [here](https://docs.chain.link/data-feeds/price-feeds/addresses?network=arbitrum). For $ARB/$USD, we’ll use the address `0xb2A824043730FE05F3DA2efaFa1CBbe83fa548D6`.

We can now build the function to get the latest price of $ARB. We’ll use this example contract:

```solidity
contract ARBPriceConsumer {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Arbitrum One
     * Aggregator: ARB/USD
     * Address: 0xb2A824043730FE05F3DA2efaFa1CBbe83fa548D6
     */
		address constant PROXY = 0xb2A824043730FE05F3DA2efaFa1CBbe83fa548D6;

    constructor() {
        priceFeed = AggregatorV3Interface(PROXY);
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}
```

You can adapt this contract to your needs. Just remember to use the address of the asset you want to request the price for in the appropriate network, and to **deploy your contract to the same network**. Remember we have a [Quickstart](../for-devs/quickstart-solidity-hardhat) available that goes through the process of compiling and deploying a contract.

### More examples

Refer to [Chainlink’s documentation](https://docs.chain.link/) for more examples of querying price feeds plus other data feeds available.

## API3

[API3](https://api3.org/) is a collaborative project to deliver traditional API services to smart contract platforms in a decentralized and trust-minimized way. API3 provides the technology for Airnodes to push off-chain data to on-chain contracts. This data can then be queried directly through the Airnode (initiating a “pull-type” request) or through dAPIs (data feeds of up-to-date off-chain data).

### Querying the price of $ARB through API3

Here’s an example on how to use an API3 data feed to query the current price of $ARB on-chain. The [API3 market](https://market.api3.org/) provides a list of all the dAPIs available across multiple chains including testnets. These dAPIs are self-funded so, before querying it, we must make sure they have enough funds to cover our test.

API3 provides an npm package with the contracts needed to access their feeds. We first install that package in our project:

```bash
yarn add @api3/contracts
```

To use a data feed, we retrieve the information through the specific proxy address for that feed. We’ll use the IProxy interface to do so.

```solidity
import "@api3/contracts/v0.8/interfaces/IProxy.sol";
```

In this case, we want to obtain the current price of $ARB in $USD in Arbitrum One, so we need to know the address of the proxy that will provide that information. We will search the feed on the API3 Market, connect our wallet and click on `Get Proxy`. The ARB/USD proxy address is `0x0cB281EC7DFB8497d07196Dc0f86D2eFD21066A5`.

We can now build the function to get the latest price of $ARB. We’ll use this example contract:

```solidity
contract ARBPriceConsumer {
    /**
     * Network: Arbitrum One
     * Aggregator: ARB/USD
     * Proxy: 0x0cB281EC7DFB8497d07196Dc0f86D2eFD21066A5
     */
    address constant PROXY = 0x0cB281EC7DFB8497d07196Dc0f86D2eFD21066A5;

    /**
     * Returns the latest price.
     */
    function getLatestPrice()
        external
        view
        returns (int224 value, uint256 timestamp)
    {
        (value, timestamp) = IProxy(PROXY).read();
        // If you have any assumptions about `value` and `timestamp`, make sure
        // to validate them right after reading from the proxy.
    }
}
```

You can adapt this contract to your needs. Just remember to use the address of the asset you want to request the price for in the appropriate network, and to **deploy your contract to the same network**. Remember we have a [Quickstart](../for-devs/quickstart-solidity-hardhat) available that goes through the process of compiling and deploying a contract.

### Querying a random number through API3

[API3 QRNG](https://docs.api3.org/explore/qrng/) is a public utility provided with the courtesy of [Australian National University (ANU)](https://www.anu.edu.au/). It is served as a public good, it is free of charge (apart from the gas costs), and it provides quantum randomness when requiring RNG on-chain.

To request randomness on-chain, the requester submits a request for a random number to `AirnodeRrpV0`. The ANU Airnode gathers the request from the `AirnodeRrpV0` protocol contract, retrieves the random number off-chain, and sends it back to `AirnodeRrpV0`. Once received, it performs a callback to the requester with the random number.

Here’s an example of a basic `QrngRequester` that requests a random number.

API3 provides an npm package with the contracts needed to access the ANU qrng airnode. We first install that package in our project:

```bash
yarn add @api3/airnode-protocol
```

We’ll need several information to request a random number:

- `address airnodeRrp`: Address of the protocol contract. See the [Chains](https://docs.api3.org/reference/qrng/chains.html) page for a list of addresses on different chains. For Arbitrum, we’ll use `0xb015ACeEdD478fc497A798Ab45fcED8BdEd08924`.
- `address airnode`: The address that belongs to the Airnode that will be called to get the QRNG data via its endpoints. See the [Providers](https://docs.api3.org/reference/qrng/providers.html) page for a list of addresses on different chains. For Arbitrum we’ll use `0x9d3C147cA16DB954873A498e0af5852AB39139f2`.
- `bytes32 endpointId`: Endpoint ID known by the Airnode that will map to an API provider call (allowed to be `bytes32(0)`). You can also find that information in the [Providers](https://docs.api3.org/reference/qrng/providers.html) page. For Arbitrum we’ll use `0xfb6d017bb87991b7495f563db3c8cf59ff87b09781947bb1e417006ad7f55a78`.

We can now build the function to get a random number. We’ll use this example contract:

```solidity
import "@api3/airnode-protocol/contracts/rrp/requesters/RrpRequesterV0.sol";

contract QrngRequester is RrpRequesterV0 {
    event RequestedUint256(bytes32 indexed requestId);
    event ReceivedUint256(bytes32 indexed requestId, uint256 response);

    /**
     * Network: Arbitrum One
     * AirnodeRrpV0 Address: 0xb015ACeEdD478fc497A798Ab45fcED8BdEd08924
     * Airnode: 0x9d3C147cA16DB954873A498e0af5852AB39139f2
     * Endpoint ID: 0xfb6d017bb87991b7495f563db3c8cf59ff87b09781947bb1e417006ad7f55a78
     */
    address constant _airnodeRrp = 0xb015ACeEdD478fc497A798Ab45fcED8BdEd08924;
    address constant airnode = 0x9d3C147cA16DB954873A498e0af5852AB39139f2;
    bytes32 constant endpointIdUint256 = 0xfb6d017bb87991b7495f563db3c8cf59ff87b09781947bb1e417006ad7f55a78;
    mapping(bytes32 => bool) public waitingFulfillment;

    constructor() RrpRequesterV0(_airnodeRrp) {}

    function makeRequestUint256() external {
        bytes32 requestId = airnodeRrp.makeFullRequest(
            airnode,
            endpointIdUint256,
            address(this),
            msg.sender,
            address(this),
            this.fulfillUint256.selector,
            ""
        );
        waitingFulfillment[requestId] = true;
        emit RequestedUint256(requestId);
    }

    function fulfillUint256(bytes32 requestId, bytes calldata data)
        external
        onlyAirnodeRrp
    {
        require(
            waitingFulfillment[requestId],
            "Request ID not known"
        );
        waitingFulfillment[requestId] = false;
        uint256 qrngUint256 = abi.decode(data, (uint256));

        // Use `qrngUint256` here...

        emit ReceivedUint256(requestId, qrngUint256);
    }
}
```

You can adapt this contract to your needs. Just remember to use the addresses of the appropriate network, and to **deploy your contract to the same network**. Remember we have a [Quickstart](../for-devs/quickstart-solidity-hardhat) available that goes through the process of compiling and deploying a contract.

### More examples

Refer to [API3’s documentation](https://docs.api3.org/) for more examples of querying other data feeds and Airnodes.

## Tellor

[Tellor](https://tellor.io/) is a decentralized oracle network that incentivizes an open, permissionless network of data reporting and validation, ensuring that any verifiable data can be brought on-chain. It supports basic spot prices, sophisticated pricing specs (TWAP/VWAP), Snapshot Vote Results, and custom data needs.

### Querying the price of $ETH through Tellor

Here’s an example on how to use a Tellor data feed to query the current price of $ETH on-chain. The way it works is that a query is crafted asking for the price of one currency against another and sent to the oracle contract. If the information for that query is available, it will be returned. Oracle contracts can be found in the [Contracts Reference](https://docs.tellor.io/tellor/the-basics/contracts-reference) page.

Tellor provides an npm package with the contracts needed to query the contract. We first install that package in our project:

```bash
npm install usingtellor
```

Our function will just wrap the call to the oracle contract with the query we are interested in. In this case we want to obtain the “SpotPrice” of “eth” against “usd”. We will request this information to the Arbitrum oracle contract `0xD9157453E2668B2fc45b7A803D3FEF3642430cC0`. We’ll use this example contract:

```solidity
contract ARBPriceConsumer is UsingTellor {
    /**
     * Network: Arbitrum One
     * Aggregator: ARB/USD
     * Address: 0xD9157453E2668B2fc45b7A803D3FEF3642430cC0
     */
    constructor(address payable _tellorAddress) UsingTellor(_tellorAddress)
    {}

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (uint256) {
        bytes memory _queryData = abi.encode("SpotPrice", abi.encode("eth", "usd"));
        bytes32 _queryId = keccak256(_queryData);

        (bytes memory _value, uint256 _timestampRetrieved) =
            getDataBefore(_queryId, block.timestamp - 20 minutes);
        if (_timestampRetrieved == 0) return 0;
        require(block.timestamp - _timestampRetrieved < 24 hours);
        return abi.decode(_value, (uint256));
    }
}
```

You can adapt this contract to your needs. Just remember to use the ticker of the assets you want to request the price for, and to **deploy your contract to the appropriate network, with the address of the oracle contract in that network**. Remember we have a [Quickstart](../for-devs/quickstart-solidity-hardhat) available that goes through the process of compiling and deploying a contract.

### More examples

Refer to [Tellor’s documentation](https://docs.tellor.io/) for more examples of querying price feeds plus other data feeds available.

## Supra

Supra is a novel, high-throughput Oracle & IntraLayer: A vertically integrated toolkit of cross-chain solutions (data oracles, asset bridges, automation network, and more) that interlink all blockchains, public (L1s and L2s) or private (enterprises).

### How to use Supras' Price Feeds

Integrating with Supras' Price Feeds is quick and easy. Supra currently supports several Solidity/EVM-based networks, like Arbitrum, and non-EVM networks like Sui, Aptos.

To see all of the networks Supra is on, please visit [Supras' Networks](https://supraoracles.com/docs/price-feeds/networks)!

To get started, you will want to visit [Supras' docs site](https://supraoracles.com/docs/price-feeds/) and review the documentation or continue to follow this guide for a quick start.

### Step 1: Create The S-Value Interface

Add the following code to the solidity smart contract that you wish to retrieve an S-Value.

```
interface ISupraSValueFeed {

    function getSvalue(uint64 _pairIndex) external view returns (bytes32, bool);

    function getSvalues(uint64[] memory _pairIndexes) external view returns (bytes32[] memory, bool[] memory);

}
```

This creates the interface that you will later apply in order to fetch a price from SupraOracles.

### Step 2: Configure The S-Value Feed Address

To fetch the S-Value from a SupraOracles smart contract, you must first find the S-Value Feed Address for the chain of your choice.

For Arbitrum, the address is: 0x8a358F391d93f7558D5F5E61BDf533e2cc3Cf7a3

When you have the proper address, create an instance of the S-Value Feed using the interface we previously defined for Arbitrum:

```
contract ISupraSValueFeedExample {
    ISupraSValueFeed internal sValueFeed;
    constructor() {
        sValueFeed = ISupraSValueFeed(0x8a358F391d93f7558D5F5E61BDf533e2cc3Cf7a3);
    }
}
```

### Step 3: Add unpack function to decode response for S-Value feed

To decode S-value response from SupraOracles smart contract, you need to add the following code in your contract.

```
// Some codefunction unpack(bytes32 data) internal pure returns(uint256[4] memory) {
        uint256[4] memory info;

        info[0] = bytesToUint256(abi.encodePacked(data >> 192));       // round
        info[1] = bytesToUint256(abi.encodePacked(data << 64 >> 248)); // decimal
        info[2] = bytesToUint256(abi.encodePacked(data << 72 >> 192)); // timestamp
        info[3] = bytesToUint256(abi.encodePacked(data << 136 >> 160)); // price

        return info;
    }

    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {
        require(_bs.length == 32, "bytes length is not 32.");
        assembly {
            value := mload(add(_bs, 0x20))
        }
    }
```

### Step 4: Get The S-Value Crypto Price

Now you can simply access the S-Value Crypto Price of our supported market pairs. In this step, we'll get the price of single or multiple trading pairs in our smart contract.

```
function getPrice(uint64 _priceIndex) external view returns (uint256[4] memory) {

        (bytes32 val,)= sValueFeed.getSvalue(_priceIndex);

        uint256[4] memory decoded = unpack(val);

        return decoded;
}

function getPriceForMultiplePair(uint64[] memory _pairIndexes) external view returns (uint256[4][] memory) {

        (bytes32[] memory val, ) = sValueFeed.getSvalues(_pairIndexes);

        uint256[4][] memory decodedArray = new uint256[4][](val.length);

        for(uint i=0; i< val.length; i++){

            uint256[4] memory decoded = unpack(val[i]);
            decodedArray[i] = decoded;
        }

        return decodedArray;
}
```

Tada! You now have a method in your Smart Contract that you can call at any time to retrieve the price of any crypto pair!

## Supra VRF

Supra’s VRF can provide the exact properties required for a random number generator (RNG) to be fair with tamper-proof, unbiased, and cryptographically verifiable random numbers to be employed by smart contracts.

## How to use Supras' VRF

Integrating with Supras' VRF is quick and easy. Supra currently supports several Solidity/EVM-based networks, like Arbitrum, and non-EVM networks like Sui, Aptos.

To see all of the networks Supra is on, please visit [Supras' Networks](https://supraoracles.com/docs/vrf/networks)!

To get started, you will want to visit [Supras' docs site](https://supraoracles.com/docs/vrf) and review the documentation or continue to follow this guide for a quick start.

Latest version of Supra VRF requires a customer controlled wallet address to act as the main reference for access permissions and call back(response) transaction gas fee payments. Therefore, users planning to consume Supra VRF should get in touch with our team to get your wallet registered with Supra.

Once your wallet is registered by the Supra team, you could use it to whitelist any number of VRF requester smart contracts and pre-pay/top up the deposit balance maintained with Supra in order to pay for the gas fees of callback(response) transactions.

You will be interacting with two main contracts:

- **Supra Deposit Contract:** To whitelist smart contracts under the registered wallet address, pre-pay/top up the callback gas fee deposit maintained with Supra.
- **Supra Router Contract:** To request and receive random numbers.

## Step 1: Create the Supra Router Contract Interface​

Add the following code to the requester contract i.e, the contract which uses VRF as a service. You can also add the code in a separate Interface and inherit the interface in the requester contract.

```
interface ISupraRouterContract {
	function generateRequest(string memory _functionSig, uint8 _rngCount, uint256 _numConfirmations, uint256 _clientSeed, address _clientWalletAddress) external returns(uint256);
	function generateRequest(string memory _functionSig, uint8 _rngCount, uint256 _numConfirmations, address _clientWalletAddress) external returns(uint256);
}
```

This interface will help the requester contract interact with the Supra Router contract and through which the requester contract can use the VRF service.

## Step 2: Configure the Supra Router Contract Address​

Contracts that need random numbers should utilize the Supra Router Contract. In order to do that, they need to create an interface and bind it to the on-chain address of the Supra router contract.

```
contract ExampleContract {
    ISupraRouter internal supraRouter;

    constructor(address routerAddress) {
        supraRouter = ISupraRouter(0x7d86fbfc0701d0bf273fd550eb65be1002ed304e);
    }
}
```

## Step 3: Use the VRF service and request a Random Number​

In this step, we will use the “generateRequest” function of the Supra Router Contract to create a request for random numbers. There are two modes for the "generateRequest" function. The only difference between them is that you can optionally provide a client-side input, which will also be part of the payload being threshold signed to provide randomness.

\_functionSig- a string parameter, here the requester contract will have to pass the function signature which will receive the callback i.e., a random number from the Supra Router Contract. The function signature should be in the form of the function name following the parameters it accepts. We will see an example later in the document.
\_rngCount - an integer parameter, it is for the number of random numbers a particular requester wants to generate. Currently, we can generate a maximum of 255 random numbers per request.
\_numConfirmations - an integer parameter that specifies the number of block confirmations needed before supra VRF can generate the random number.
\_clientSeed (optional) - an optional integer parameter that could be provided by the client (defaults to 0). This is for additional unpredictability. The source of the seed can be a UUID of 256 bits. This can also be from a centralized source.
\_clientWalletAddress - an “address” type parameter, which takes the client wallet address which is already registered with the Supra Team, as input.
Supra's VRF process requires splitting the contract logic into two functions.
The request function - the signature of this function is up to the developer
The callback function - the signature must be of the form “uint256 nonce, uint256[] calldata rngList”

```
function exampleRNG() external {
     //Function validation and logic
     // requesting 10 random numbers
     uint8 rngCount = 10;

     // we want to wait for 1 confirmation before the request is considered complete/final
     uint256 numConfirmations = 1;
	address _clientWalletAddress = //Add the whitelisted wallet address here
     uint256 generated_nonce = supraRouter.generateRequest(“exampleCallback(uint256,uint256[])”, rngCount, numConfirmations, _clientWalletAddress);

     // store generated_nonce if necessary (eg: in a hashmap)
     // this can be used to track parameters related to the request, such as user address, nft address etc in a lookup table
     // these can be accessed inside the callback since the response from supra will include the nonce
}
```

## Step 4 - Add the validation in the callback function of requester contract​

Inside the callback function where the requester contract wants the random number (in this example the callback function is exampleCallback), the requester contract will have to add the validation such that only the Supra router contract can call the function. The validation is necessary to protect against malicious contracts/users executing the callback with fake data. For example, if the callback function is pickWinner in the requester contract, the snippet can be as follows.

```
function exampleCallback(uint256 _nonce ,uint256[] _rngList) external {
    require(msg.sender == address(SupraRouter));
    // Following the required logic of the function
 }
```

## Step 5 : Whitelist your requester contract with Supra Deposit Contract and deposit funds​

It is important to note that your wallet address must be registered with Supra before this step. If that is completed, then you need to whitelist your requester smart contract under your wallet address and deposit funds to be paid for your call back transactions gas fees.
The simplest way to interact with the deposit contract will be through Remix IDE.
Go to Remix IDE & create a file with name IDepositContract.sol
Paste the following code in the file:

```
interface IDepositUserContract {
	function depositFundClient() external payable;
	function addContractToWhitelist(address _contractAddress) external;
	function removeContractFromWhitelist(address _contractAddress) external;
	function setMinBalanceClient(uint256 _limit) external;
	function withdrawFundClient(uint256 _amount) external;
	function checkClientFund(address _clientAddress) external view returns (uint256);
	function checkEffectiveBalance(address _clientAddress) external view returns (uint256);
	function checkMinBalanceSupra() external view returns (uint256);
	function checkMinBalance(address _clientAddress) external view returns(uint256);
	function countTotalWhitelistedContractByClient(address _clientAddress) external view returns (uint256);
	function getSubscriptionInfoByClient(address _clientAddress) external view returns (uint256, uint256, bool);
	function isMinimumBalanceReached(address _clientAddress) external view returns (bool);
	function listAllWhitelistedContractByClient(address _clientAddress) external view returns (address[] memory);

}
```

Navigate to the “Navigate & run Transactions” tab in remix, and Paste the Deposit Contract Address into the text box besides the “At Address” button & Press the At Address button. You will find the instance for the Deposit Contract created using which a user can interact and use the features provided by the Deposit Contract.
Following functions will facilitate whitelisting your requester smart contracts and fund deposits.
“addContracttoWhitelist(address)” - The whitelisted users will have to whitelist their contract which they will be using to request for random numbers. The parameter this function takes is the User’s contract address. This function will be called after the user deploys the requester contract post development and makes it ready for interacting with the Supra Contracts.
“depositFundClient()” - is another mandatory function for a user to use once, before the user starts requesting from that contract. This is a function which will deposit funds in the deposit contract from the users for the response/callback transaction. The funds for a specific user should remain higher than the minimum amount set by the Supra( 0.1 Eth for Arbitrum testnet) for the new request transactions to be accepted.  
Basically the gist here is that the user will have to interact with the Deposit contract and add funds for their accounts, which will be utilized for the response transaction gas fee. There will be a script from Supra which will be monitoring the funds and will alert the user if a refill is required.

## Example Implementation

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
interface ISupraRouter {
   function generateRequest(string memory _functionSig , uint8 _rngCount, uint256 _numConfirmations, uint256 _clientSeed,address _clientWalletAddress) external returns(uint256);
   function generateRequest(string memory _functionSig , uint8 _rngCount, uint256 _numConfirmations,address _clientWalletAddress) external returns(uint256);
}
contract Interaction {
   address supraAddr;
   constructor(address supraSC) {
       supraAddr = supraSC;
   }
   mapping (uint256 => string ) result;
   mapping (string => uint256[] ) rngForUser;
   function getRNGForUser(uint8 rngCount, string memory username) external {
      uint256 nonce =  ISupraRouter(supraAddr).generateRequest("myCallbackUsername(uint256,uint256[])", rngCount, 1, 123, msg.sender);
//Can pass "msg.sender" when calling from the whitelisted wallet address
      result[nonce] = username;
   }
   function myCallbackUsername(uint256 nonce, uint256[] calldata rngList) external {
      require(msg.sender == supraAddr, "only supra router can call this function");
      uint8 i = 0;
      uint256[] memory x = new uint256[](rngList.length);
      rngForUser[result[nonce]] = x;
      for(i=0; i<rngList.length;i++){
         rngForUser[result[nonce]][i] = rngList[i] % 100;
      }
   }
   function viewUserName(string memory username) external view returns (uint256[] memory) {
      return rngForUser[username];
   }
   }
```

## Going Further with Supra

If you want to take the next step, consider registering for the [Supra Network Activate Program (SNAP)](https://join.supraoracles.com/network-activate-program).

The Supra Network Activate Program (SNAP) offers companies discounted oracle credits, technical documentation, and customer support to embed much-needed oracles and VRF/RNG. SNAP supports Web3 scaling and growth to buffer costs which could typically inhibit a company’s success.

The SNAP program is partnered with some of Web3's most prolific names who are helping with project selection and qualification.

## Connect with us!

Still looking for answers? We got them! Check out all the ways you can reach us:

- Visit us at [supraoracles.com](https://supraoracles.com)
- Read our [Docs](https://supraoracles.com/docs/overview)
- Chat with us on [Telegram](https://t.me/SupraOracles)
- Follow us on [Twitter](https://twitter.com/SupraOracles)
- Join our [Discord](https://discord.gg/supraoracles)
- Check us out on [Youtube](https://www.youtube.com/SupraOfficial)
